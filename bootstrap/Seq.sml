(*   Sequences based on 2-3 finger trees
 *
 * In [Hinze & Paterson, 2006] it is suggested that performance is improved by
 * using a specialised digit datatype al√°
 *   datatype 'a digit =
 *            One of 'a
 *          | Two of 'a * 'a
 *          | Three of 'a * 'a * 'a
 *          | Four of 'a * 'a * 'a * 'a
 *
 * However this seems not to be the case (using MLTon at least). On top of that
 * the implementation is much more complicated. For those reasons this
 * implementation models digits (and tree nodes) using lists.
 *
 * The implementation suggested by [Hinze & Paterson, 2006] can be found in
 * SeqHinzePaterson.sml. The append function is generated by GenSeqApp.sml.
 *
 *
 * [Hinze & Paterson, 2006]
 *   Ralf Hinze and Ross Paterson,
 *   "Finger trees: a simple general-purpose data structure"
 *   Journal of Functional Programming 16:2 (2006) pp 197-217
 *   http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
 *)

structure Seq =
struct
infix <| |> ><
datatype 'a t =
         E
       | S of 'a tree
       | D of int * 'a tree digit * 'a t * 'a tree digit
     and 'a tree =
         N of 'a
       | B of int * 'a tree list
withtype 'a digit = 'a list

val empty = E
fun genEmpty () = E

fun null E = true
  | null _ = false

fun singleton x = S (N x)

fun length' t =
    case t of
      N _ => 1
    | B (s, _) => s

fun length'' ts = List.foldl (fn (t, s) => length' t + s) 0 ts

fun length xs =
    case xs of
      E => 0
    | S t => length' t
    | D (s, _, _, _) => s

fun branch ts =
    case ts of
      [t1, t2] => B (length' t1 + length' t2, ts)
    | [t1, t2, t3] => B (length' t1 + length' t2 + length' t3, ts)
    | _ => die "Seq.branch: not 2 or 3 subtrees"
fun unbranch t =
    case t of
      B (_, ts) => ts
    | _ => die "Seq.unbranch: node"

fun cons' (x, xs) =
    case xs of
      E => S x
    | S y => D (length' x + length' y, [x], E, [y])
    | D (s, a :: (pr as [_, _, _]), m, sf) =>
      D (s + length' x, [x, a], cons' (branch pr, m), sf)
    | D (s, pr, m, sf) =>
      D (s + length' x, x :: pr, m, sf)

fun snoc' (x, xs) =
    case xs of
      E => S x
    | S y => D (length' x + length' y, [y], E, [x])
    | D (s, pr, m, d :: (sf as [_, _, _])) =>
      D (s + length' x, pr, snoc' (branch sf, m), [x, d])
    | D (s, pr, m, sf) =>
      D (s + length' x, pr, m, x :: sf)

fun x <| xs = cons' (N x, xs)
fun xs |> x = snoc' (N x, xs)

fun getl' xs =
    case xs of
      E => NONE
    | S x => SOME (x, E)
    | D (s, pr, m, sf) =>
      case pr of
        [x] =>
        SOME
          (x,
           case getl' m of
             NONE =>
             (case sf of
                [y] => S y
              | y :: ys => D (s - length' x, rev ys, E, [y])
              | _ => die "Seq.viewl': empty suffix"
             )
           | SOME (t, m) => D (s - length' x, unbranch t, m, sf)
          )
      | x :: pr =>
        SOME (x, D (s - length' x, pr, m, sf))
      | _ => die "Seq.viewl': empty prefix"

fun getr' xs =
    case xs of
      E => NONE
    | S x => SOME (x, E)
    | D (s, pr, m, sf) =>
      case sf of
        [x] =>
        SOME
          (x,
           case getr' m of
             NONE =>
             (case pr of
                [y] => S y
              | y :: ys => D (s - length' x, [y], E, rev ys)
              | _ => die "Seq.viewr': got empty prefix"
             )
           | SOME (t, m) => D (s - length' x, pr, m, unbranch t)
          )
      | x :: sf =>
        SOME (x, D (s - length' x, pr, m, sf))
      | _ => die "Seq.viewr': got empty suffix"

fun getl xs =
    case getl' xs of
      NONE => NONE
    | SOME (N x, xs) => SOME (x, xs)
    | _ => die "Seq.viewl: got a branch"

fun getr xs =
    case getr' xs of
      NONE => NONE
    | SOME (N x, xs) => SOME (x, xs)
    | _ => die "Seq.viewr: got a branch"

fun swapdir s n = s - n - 1

fun split'' n ts =
    case ts of
      t :: ts =>
      let
        val s = length' t
      in
        if s <= n then
          let
            val (ts, t', us) = split'' (n - s) ts
          in
            (t :: ts, t', us)
          end
        else
          (nil, t, ts)
      end
    | _ => die "Seq.split''"

fun liftl ts =
    case ts of
      nil => E
    | [t] => S t
    | t :: ts' => D (length'' ts, [t], E, rev ts')

and liftr ts =
    case ts of
      nil => E
    | [t] => S t
    | t :: ts' => D (length'' ts, rev ts', E, [t])

and deepl pr m sf =
    case pr of
      nil =>
      (case getl' m of
         NONE =>
         liftr sf
       | SOME (t, m) =>
         D (length' t + length m + length'' sf, unbranch t, m, sf)
      )
    | _ =>
      D (length'' pr + length m + length'' sf, pr, m, sf)

and deepr pr m sf =
    case sf of
      nil =>
      (case getr' m of
         NONE =>
         liftl pr
       | SOME (t, m) =>
         D (length'' pr + length m + length' t, pr, m, unbranch t)
      )
    | _ =>
      D (length'' pr + length m + length'' sf, pr, m, sf)

fun digest n (d as (s, pr, m, sf)) dpr dm dsf =
    if n < s div 2 then
      let
        val lpr = length'' pr
      in
        if n < lpr then
          dpr (n, d)
        else
          let
            val lm = length m
            val n' = n - lpr
          in
            if n' < lm then
              dm (n', d)
            else
              dsf (swapdir s n, d)
          end
      end
    else
      let
        val n' = swapdir s n
        val lsf = length'' sf
      in
        if n' < lsf then
          dsf (n', d)
        else
          let
            val lm = length m
            val n' = swapdir lm (n' - lsf)
          in
            if n' >= 0 then
              dm (n', d)
            else
              dpr (n, d)
          end
      end

fun guardIndex n xs =
    if n < 0 orelse n >= length xs then
      raise Subscript
    else
      ()

fun split n xs =
    case xs of
      E => raise Subscript
    | S x => (E, x, E)
    | D d =>
      digest n d
             (fn (n, (_, pr, m, sf)) =>
                 let
                   val (l, x, r) = split'' n pr
                 in
                   (liftl l, x, deepl r m sf)
                 end)
             (fn (n, (_, pr, m, sf)) =>
                 let
                   val (ml, xs, mr) = split n m
                   val (l, x, r) = split'' (n - length ml) (unbranch xs)
                 in
                   (deepr pr ml l, x, deepl r mr sf)
                 end)
             (fn (n, (_, pr, m, sf)) =>
                 let
                   val (r, x, l) = split'' n sf
                 in
                   (deepr pr m l, x, liftr r)
                 end)

fun splitAt n xs =
    (guardIndex n xs
   ; case split n xs of
       (l, N x, r) => (l, x, r)
     | _ => die "Seq.splitAt: branch"
    )

fun ad'' ad' f n ts =
    case ts of
      t :: ts =>
      let
        val s = length' t
      in
        if s <= n then
          t :: ad'' ad' f (n - s) ts
        else
          ad' f n t :: ts
      end
    | _ => die "Seq.ad'': n > s"

fun adl' f n t =
    case t of
      N x => N (f x)
    | B (s, ts) => B (s, ad'' adl' f n ts)

fun adr' f n t =
    adl' f (swapdir (length' t) n) t

fun ad f n xs =
    case xs of
      E => raise Subscript
    | S t => S (adl' f n t)
    | D d =>
      digest n d
             (fn (n, (s, pr, m, sf)) =>
                 D (s, ad'' adl' f n pr, m, sf)
             )
             (fn (n, (s, pr, m, sf)) =>
                 D (s, pr, ad f n m, sf)
             )
             (fn (n, (s, pr, m, sf)) =>
                 D (s, pr, m, ad'' adr' f n sf)
             )

fun adjust f n xs =
    (guardIndex n xs ; ad f n xs)

and ind'' ind' n ts =
    case ts of
      t :: ts =>
      let
        val s = length' t
      in
        if s <= n then
          ind'' ind' (n - s) ts
        else
          ind' n t
      end
    | _ => die "Seq.ind'': n > s"

fun indl' n t =
    case t of
      N x => x
    | B (s, ts) => ind'' indl' n ts

fun indr' n t =
    indl' (swapdir (length' t) n) t

fun indl n xs =
    case xs of
      E => raise Subscript
    | S t => indl' n t
    | D d =>
      digest n d
             (fn (n, (_, pr, _, _)) =>
                 ind'' indl' n pr
             )
             (fn (n, (_, _, m, _)) =>
                 indl n m
             )
             (fn (n, (_, _, _, sf)) =>
                 ind'' indr' n sf
             )

fun index n xs =
    (guardIndex n xs ; indl n xs)

fun foldl'many f b ts = List.foldl (fn (t, b) => foldl' f b t) b ts
and foldl' f b t =
    case t of
      N x => f (x, b)
    | B (_, ts) => foldl'many f b ts
fun foldl f b xs =
    case xs of
      E => b
    | S t => foldl' f b t
    | D (_, pr, m, sf) =>
      foldl'many f (foldl f (foldl'many f b pr) m) sf

fun foldr'many f b ts = List.foldr (fn (t, b) => foldr' f b t) b ts
and foldr' f b t =
    case t of
      N x => f (x, b)
    | B (_, ts) => foldr'many f b ts
fun foldr f b xs =
    case xs of
      E => b
    | S t => foldr' f b t
    | D (_, pr, m, sf) =>
      foldl'many f (foldr f (foldl'many f b sf) m) pr

fun map' f t =
    case t of
      N x => N (f x)
    | B (s, ts) => B (s, List.map (map' f) ts)
fun map f xs =
    case xs of
      E => E
    | S t => S (map' f t)
    | D (s, pr, m, sf) =>
      D (s, List.map (map' f) pr, map f m, List.map (map' f) sf)

fun app (xs, ts, ys) =
    let
      fun cons'many (ts, xs) = List.foldr cons' xs ts
      fun snoc'many (ts, xs) = List.foldl snoc' xs ts
      fun node xs =
          case xs of
            nil => nil
          | [a, b] => [branch [a, b]]
          | [a, b, c, d] => [branch [a, b], branch [c, d]]
          | a :: b :: c :: xs => branch [a, b, c] :: node xs
          | _ => die "Seq.app.node: got singleton list"
    in
      case (xs, ys) of
        (E, _) => cons'many (ts, ys)
      | (_, E) => snoc'many (ts, xs)
      | (S x, _) => cons' (x, cons'many (ts, ys))
      | (_, S y) => snoc' (y, snoc'many (ts, xs))
      | (D (sl, prl, ml, sfl), D (sr, prr, mr, sfr)) =>
        D (sl + length'' ts + sr, prl, app (ml, node (sfl @ ts @ prr), mr), sfr)
    end

fun xs >< ys = app (xs, nil, ys)

fun rev' t =
    case t of
      N _ => t
    | B (s, ts) => B (s, rev'' ts)
and rev'' ts = List.rev (List.map rev' ts)

fun rev xs =
    case xs of
      E => xs
    | S _ => xs
    | D (s, pr, m, sf) => D (s, rev'' pr, rev m, rev'' sf)
end
